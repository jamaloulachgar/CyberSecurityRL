import java.util.HashMap;
import java.util.Map;

public class VulnerabilityScanner {
    private NetworkEnvironment environment;
    private Map<Integer, Double> vulnerabilityScores; // Score de vulnérabilité par nœud
    private static final double PORT_VULNERABILITY_FACTOR = 0.3; // Facteur de vulnérabilité par port
    private static final double CONNECTION_FACTOR = 0.2; // Facteur basé sur les connexions
    private static final double CONTROL_DURATION_FACTOR = 0.5; // Facteur basé sur la durée de contrôle

    public VulnerabilityScanner(NetworkEnvironment environment) {
        this.environment = environment;
        this.vulnerabilityScores = new HashMap<>();
        initializeVulnerabilityScores();
    }

    private void initializeVulnerabilityScores() {
        int[] ports = environment.getPorts();
        for (int i = 0; i < environment.getNumOfNodes(); i++) {
            double portScore = calculatePortVulnerability(ports[i]) * PORT_VULNERABILITY_FACTOR;
            vulnerabilityScores.put(i, portScore);
        }
    }

    private double calculatePortVulnerability(int port) {
        // Pondération personnalisée des ports (ex. : Telnet plus vulnérable que HTTPS)
        switch (port) {
            case 23: // Telnet
                return 0.8; // Très vulnérable
            case 80: // HTTP
                return 0.6;
            case 445: // SMB
                return 0.5;
            case 443: // HTTPS
                return 0.2; // Moins vulnérable
            default:
                return 0.4;
        }
    }

    public void updateVulnerability(int node, int durationControlledByAttacker) {
        int connections = environment.getNeighboursMatrix()[node].length;
        double baseScore = vulnerabilityScores.getOrDefault(node, 0.0);
        double controlScore = Math.min(1.0, durationControlledByAttacker * CONTROL_DURATION_FACTOR);
        double connectionScore = connections * CONNECTION_FACTOR;
        double newScore = baseScore + controlScore + connectionScore;

        vulnerabilityScores.put(node, Math.min(1.0, newScore)); // Cap à 1.0
    }

    public Map<Integer, Double> getVulnerabilityScores() {
        return new HashMap<>(vulnerabilityScores); // Retourne une copie pour éviter les modifications directes
    }

    public String getCountermeasureSuggestion(int node) {
    double score = vulnerabilityScores.getOrDefault(node, 0.0);
    StringBuilder suggestion = new StringBuilder();

    // Ajouter le contexte du nœud et son score
    suggestion.append("Nœud ").append(node).append(" - Vulnérabilité : ").append(String.format("%.0f%%", score * 100));

    // Si le score est supérieur à 0.5, suggérer des actions
    if (score > 0.5) {
        int port = environment.getPorts()[node];
        String portName = getPortName(port); // Méthode utilitaire pour obtenir le nom du port
        suggestion.append("\nAlerte : Niveau de vulnérabilité élevé.\n");
        suggestion.append("Recommandation : Fermer le port ").append(port).append(" (").append(portName).append(").");

        // Si le score est très élevé (> 0.8), ajouter une suggestion supplémentaire
        if (score > 0.8) {
            suggestion.append("\nAction urgente : Isoler le nœud ").append(node).append(" pour limiter les risques.");
        }
    } else {
        suggestion.append("\nStatut : Sécurisé. Aucune action immédiate requise.");
    }

    return suggestion.toString();
}

// Méthode utilitaire pour obtenir le nom du port
private String getPortName(int port) {
    switch (port) {
        case 23:
            return "Telnet";
        case 80:
            return "HTTP";
        case 445:
            return "SMB";
        case 443:
            return "HTTPS";
        default:
            return "Inconnu";
    }
}
}